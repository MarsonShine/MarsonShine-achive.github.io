# 锁

多用户对共享资源的争用

## 并发冲突带来的影响

| 问题                            | 描述                                                         | 分析                                                         |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 脏读（Dirty reads）             | 当一个事务正在读取一条记录，正执行到一半；另一个事务已经完成了操作。 | 1. A 用户与 B 用户都读取 v 值为 “5”<br />2. B 将 v 更改为 “2”<br />3. A 此时已经读取的值还是 5，此时已经发生脏读 |
| 不可重复读（Unrepeatable read） | 每次读取数据的时候数据不一致，这就是 “不可重复读” 问题       | 1. A 读取 v 值为 5<br />2. B 读取 v 并更改为 2<br />3. A 刷新并读取 v 值变为 2，出乎 A 的意料，不可重复读 |
| 幻影行，幻读（Phantom Rows）    | 如果 "UPDATE" 和 "DELETE" 语句都不影响数据，那这就是幻读问题 | 1. A 更改所有的值 v 为 2<br />2. B 插入一个新记录 v 值为 2<br />3. A 选择 v 值为 2 的所有记录，他会发现多了一条 2 的记录，这就是幻读 |
| 丢失更新（Lost Updates）        | 更新丢失的场景发生在当一个更新操作成功之后，被其他事务重新覆写了 | 1. A 将所有 v 值为 5 的更新为 2<br />2. 这时 B 将所有 v 值为 2 的更新为 5<br />3. A 用户的操作已经丢失了 |





learn from https://www.codeproject.com/Articles/114262/6-ways-of-doing-locking-in-NET-Pessimistic-and-opt